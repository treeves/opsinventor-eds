<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AEM SSL Setup: AEM 6.1/6.2 &amp; Java Keystore Based SSL Configuration</title>
  <link rel="canonical" href="https://www.opsinventor.com/aem-ssl-setup-aem-6-1-6-2-java-keystore-based-ssl-configuration/">
</head>
<body>
  <article>
    <header>
      <h1>AEM SSL Setup: AEM 6.1/6.2 &amp; Java Keystore Based SSL Configuration</h1>
      <time datetime="2018-07-18T17:26:16.000Z">7/18/2018, 10:26:16 AM</time>
    </header>
    <section class="content">
      As I noted in <a href="http://www.jetteroheller.com/implementing-ssl-on-aem/">my other post on setting up AEM for server-to-server SSL</a>, doing full SSL on AEM 6.3 and 6.4 can be done fairly simply these days using a relatively easy-to-use UI for the most part, with the SSL keys themselves stored in the repository.  AEM 6.1 and 6.2 however required one to use a Java Keystore with the keys stored on-disk, a paradigm which still works for AEM 6.3/6.4 as well, though it's somewhat deprecated and also significantly more difficult.

Most of the steps are in the <a href="https://docs.adobe.com/docs/en/aem/6-2/deploy/configuring/config-ssl.html">official Adobe docs</a>, though there are a few gotchas which I'll document here to make it easier, should you need to set this up or debug it.
<h2>Generating SSL Certificates &amp; Importing into Java Keystore</h2>
First, I'll assume here that you're going to need to generate SSL certificates that need to be signed by an external cert signing authority.  Self-signed certs will work in AEM as well, but let's just assume for the purposes of the docs here that you're doing this for PRD and are required to use externally-valid SSL certs.

First, generate your cert-signing request (CSR) which will also create a JKS file and embed the private key for the SSL cert into the JKS file:
<pre class="lang:default decode:true">keytool -genkey -alias aem-author-test -keyalg RSA -keysize 2048 -keystore AEM_author_dev.jks -dname "CN=aem-author-dev.test.com, O=Companyname, L=CityName, ST=, C=US" &amp;&amp; keytool -certreq -alias aem-author-test -file AEM_author_dev.csr -keystore AEM_author_dev.jks</pre>
Then, once you get the signed certs back from your certificate authority, you may first need to install their intermediate certs or root certs into your JKS file, presuming their intermediate certs aren't embedded in the JDK.  This is a vital step if your organization runs its own cert authority.
<pre class="lang:default decode:true">#import the Root cert into the keystore
keytool -importcert -trustcacerts -file rootcert.pem -keystore AEM_author_dev.jks -alias "Root CA Cert"
 
#import the intermediate cert into the keystore, ensuring the alias is correct (you can import into a browser to check)
keytool -importcert -trustcacerts -file intermediatecert.pem -keystore AEM_author_dev.jks -alias "Intermediate Cert"</pre>
After this, you'll want to import your signed cert back into the JKS file.  First, make sure you have the alias correct for the cert you're importing (important if you're doing this for many servers).   To see the certs which are loaded in a given JKS file use:
<pre class="lang:default decode:true">[me@localhost ssl]$ keytool -list -keystore aem-author-test.jks
Enter keystore password:  
Keystore type: JKS
Keystore provider: SUN

Your keystore contains 3 entries

test root ca, Nov 14, 2017, trustedCertEntry, 
Certificate fingerprint (SHA1): E6:45:FF:B1:C6:27:FA:A4:5C:06:1E:C7:5D:53:8C:86:37:93:C2:33
aem-author-test, Nov 14, 2017, PrivateKeyEntry, 
Certificate fingerprint (SHA1): 66:5F:F2:F3:E2:F3:FF:82:6D:15:FB:F3:F1:F0:AD:A9:D8:4D:4B:9D
test intermediate ca, Nov 14, 2017, trustedCertEntry, Certificate fingerprint (SHA1): E6:45:FF:B1:C6:27:FA:A4:5C:06:1E:C7:5D:53:8C:86:37:93:C2:33
</pre>
In this case, the 'alias' you would use for your import command would be 'aem-author-test'.   The alias is just a key to the entries in the JKS database.  It's an arbitrary name and can be anything you want.

(<strong>Important Note</strong>: have not tested this alias with ¯\_(ツ)_/¯ emoji, so perhaps not <em>anything </em>you want)

Import the signed cert back in with:
<pre class="lang:default decode:true ">#import the signed cert into the keystore, using the same alias as you used above
keytool -importcert -trustcacerts -file my-signed-cert.der -keystore AEM_author_dev.jks -alias "aem-author-test"</pre>
Assuming the alias names line up between the CSR and the imported signed cert, you'll see:
<pre class="">Enter keystore password:  
Certificate reply was installed in keystore</pre>
When you import the cert.
<h2>Configuring AEM to use SSL</h2>
To get AEM to run on SSL using the certificate you've just created, you'll need to do the following:
<ol>
 	<li>Open CRXDE Lite and select the <span class="code">/apps</span> folder. Click <b>Create</b> &gt; <b>Create Folder</b> to create a folder named <span class="code">system</span> (<a href="http://localhost:4502/crx/de">http://localhost:4502/crx/de</a>).</li>
 	<li>Below the system folder create a folder named<strong> <span class="code">config.author </span></strong><span class="code">(or <strong>config.publish</strong> if this is a publisher)</span></li>
 	<li>Select the <span class="code">/apps/system/config.author</span> node.</li>
 	<li>Click <b>Create </b>&gt; <b>Create Node</b> and enter the following properties:
<ol>
 	<li><b>Name</b>: <span class="code">org.apache.felix.http</span></li>
 	<li><b>Type</b>: <span class="code">sling:OsgiConfig</span></li>
</ol>
</li>
 	<li>Add properties to the node according to the following table:</li>
</ol>
<table border="1" width="100%" cellspacing="0" cellpadding="1">
<tbody>
<tr>
<th>Name</th>
<th>Type</th>
<th>Value</th>
</tr>
<tr>
<td><span class="code">org.apache.felix.https.enable</span></td>
<td><span class="code">Boolean</span></td>
<td><span class="code">true</span></td>
</tr>
<tr>
<td><span class="code">org.osgi.service.http.port.secure</span></td>
<td><span class="code">Long</span></td>
<td><span class="code">5443 (what you want as your AEM SSL port)</span></td>
</tr>
<tr>
<td><span class="code">org.apache.felix.https.nio</span></td>
<td><span class="code">Boolean</span></td>
<td><span class="code">true</span></td>
</tr>
<tr>
<td><span class="code">org.apache.felix.https.keystore</span></td>
<td><span class="code">String</span></td>
<td><i>/opt/aem/ssl/AEM_author_dev.jks
(or wherever you've put this keystore)</i></td>
</tr>
<tr>
<td><span class="code">org.apache.felix.https.keystore.password</span></td>
<td><span class="code">String</span></td>
<td>The keystore password</td>
</tr>
<tr>
<td><span class="code">org.apache.felix.https.keystore.key</span></td>
<td><span class="code">String</span></td>
<td>The SSL key alias noted above (i.e. aem-author-test)</td>
</tr>
<tr>
<td><span class="code">(optional) org.apache.felix.https.keystore.key.password</span></td>
<td><span class="code">String</span></td>
<td>JKS files support a password on individual certificate entries in addition to the keystore password.  If your key has one, put the password here.  Otherwise, do not include this value.</td>
</tr>
<tr>
<td><span class="code">(optional) org.apache.felix.https.truststore</span></td>
<td>String</td>
<td>Path to truststore.  If you use a 3rd-party cert signing authority, you may need to create a separate truststore which includes the 3rd-party intermedia/root certs.  If so, add this truststore path here.</td>
</tr>
<tr>
<td><span class="code">(optional) org.apache.felix.https.truststore.password</span></td>
<td>String</td>
<td>Truststore password.</td>
</tr>
<tr>
<td><span class="code">(Optional) org.apache.felix.https.clientcertificate</span></td>
<td>String</td>
<td>Defaults to none</td>
</tr>
</tbody>
</table>
&nbsp;

After you've added these nodes, click <strong>Save All</strong> in crxde.  If you're tailing the log, you'll see a number of org.apache.felix entries streaming past, and you may see SSL attempt to be enabled.  Once Felix finishes refreshing, restart the entire AEM instance.

Once AEM restarts, you should see an entry like this in the logs, indicating that it's listening on the HTTPS port:
<pre class="lang:default decode:true ">17.07.2018 22:04:01.142 *INFO* [CM Configuration Updater (ManagedService Update: pid=[org.apache.felix.http])] org.apache.felix.http.jetty Started Jetty 9.2.19.v20160908 at port(s) HTTP:4503 HTTPS:6443 on context path / [minThreads=8,maxThreads=200,acceptors=1,selectors=1]</pre>
&nbsp;
<h2>Adding Truststore to the JVM</h2>
Some features of AEM, when making outbound calls, originate from within Felix and will use the  <span class="code">org.apache.felix.https.truststore value you set up above for the truststore.  However, some other calls (replication, flush agent requests) are made directly by the JDK, and require that the truststore you added be loaded into the JDK as well.  </span>

To do this, you will need to add an extra argument into your AEM start script to add a truststore to the JVM as well:
<pre class="lang:default decode:true ">-Djavax.net.ssl.trustStore=/opt/aem/ssl/prd_truststore.jks</pre>
&nbsp;
    </section>
    <footer><p>Categories: adobe experience manager, AEM, AEM / CQ, howto, instructions, jks, setup, ssl</p></footer>
  </article>
</body>
</html>